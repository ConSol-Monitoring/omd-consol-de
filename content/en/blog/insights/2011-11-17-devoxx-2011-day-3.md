---
author: Roland Hu√ü
date: '2011-11-17T10:22:10+00:00'
slug: devoxx-2011-day-3
tags:
- conference
title: Devoxx 2011 - Day 3
---

Day 3 and Devoxx is running at full blast now. Rooms are crowded, WiFi breaks down periodically, lanes in front of the toilets and lunch lanes, but nothing will stop the FUN we are having here ;-). There we go with our reviews about the diabolical developer, Play 2.0, Kotlin, JAX-RS 2.0, NoSQL, Phone Gap, HTML5 and the JDK 7 Filesystem API. Please fasten your seat belt for some geeky stuff.

<!--more-->
# "Welcome and Announcements" by Stephan Janssen (Christian)

Finally the Devoxx conference talks started!

Stephan Janssen, the founder of Devoxx, entered the stage wearing a brazilian flag and welcomed all attendees in room 8 and started his welcome-presentation with the DEVOXX-poster this year, pointing on some symbols:

* Brazilian flag standing for Bruno Souza, a brazilian fellow and leader of one of the biggest Java user groups worldwide
* Three cups with java, android and html5 logo, no explanation needed :-)
* Joshua Blochs mother, being born in Antwerp
* Oak tree standing for the original name of Java

After that, he showed some facts about the 10th Devoxx:

* 3350 attendees from 40 countries
* 150 sessions over 5 days in 7 rooms
* 170+ speakers
* 60 java user groups

Features this year are:

* Tweetwall: All tweets sent to wall@devoxx.com are presented on the tweetwall!
* Kinect digital signage
* Multiple mobile client apps using a REST interface
* WLAN with approx. 9000 reserved IP-adresses, sometimes this limit is already exceeded!
* Personal wristbands for accessing the conference: waterproofed, scannable for lotteries, but cannot be taken off and needs to be worn during all time. I really wonder, how mine will look on friday after sleeping three nights with it!
* Cups with DEVOXX-logo for free
* All conference talks are streamed live on www.parleys.com and will be downloadable later (targetted for christmas holidays)

After almost finishing his presentation, he had one more thing... A movie-trailer with emotionally loaded music revealed the announcement of an additional Devoxx-conference on 18.-20.4.2012 Devoxx in Paris/France, mostly targetting on french Java developers.


# "Java SE Keynote" by Henrik Stahl (Alvin)

Henrik Stahl is giving the first keynote for Devoxx 2011. The room was full and the lights are up. Is there any surprises? A new Smartphone from Oracle or like :-) No, Henrik talk was about the general future directions and the history of Java.

Last 10-15 years Java evolved to a huge programming language, about 9 Million developers use Java. Java was evolving along the hardware and software ecosystem.
What is next? Java 6 is out since 2006 and now there is Java 7, packed with a number of new few features..

* Jigsaw
* Lambda clousures
* Java FX 3.0 (Java FX is going open source and will be in Open JDK)

Work is going on for the Java on Mac OSX, a beta is already available, JVM fusion between Hotspot and JRocket is underway. JavaFX will be available soon for more platforms.

But what is the point now ? A: We do the hard thing so you don't have to and let me quote this words from Henrik :

> Java will be there for you. This is a promise, a serious promise but you the java enthusiasts, please keep uptodate and we keep the java moving forward.

# "The Diabolical Developer - take the power back" by Martijn Verburg (Christian)

Well, why did I visit this session? I think, the announcement just made me curious in how far Martijn will present the uselessness of nowadays software development methodologies...

Fist of all: His appearance with dark, big sunglasses and a cool, black cap was promising, and his main entrance statement was noteworthy: In software development we have so many tools, frameworks, patterns and methods which can make people stop thinking about their disadvantages and the REAL important things while coding software.

In the following he amusingly concentrated on changing the programmers mindset, proclamating more and more ironic statements. Among them were:

* Be passionate about your work
* Code in isolation
* Re-invent the wheel: your way is best
* keep information to yourself - knowledge is power
* Don't trust the giants in your industry
* Don't talk to users... you're smarter than those guys!
* Don't go to conferences ;-)

In the second half (in between the beamer broke for about 5 minutes) he focussed more on technology and programming style:

* vi is better than any IDE
* Only use a single code file
* Designing laysers of code is pointless
* Access JSP --> DB is ok!
* Use MRP: multi-responsible-principle
* Copy and paste is fine
* Keep code on your local drive (if backup is needed, take a USB stick)
* CI is a good thing - developers are continuously integrating! (single code file)
* Testing is a waste of time - that's what users are for

As you can imagine, all attendees had a very entertaining hour. Unfortunately it was a bit hard to come to a real conclusion... Maybe it was as stated at the beginning: "Be aware of the costs of tools, patterns, frameworks and methods you introduce in your software project. You always can do it also completely without them!"

# "Play 2.0 - Web Framework for a new era" by Guillaume Bort and Sadek Drobi (Christoph)

A short audience voting at the beginning of this talk showed that a huge amount of the audience already is well known to Play Web Framework and Scala - unfortunately I am not! However I will try to sum up this talk for you. It helped me a lot that the talk was structured very well and the demos were great in order to understand the speaker's intentions, even for Scala newbies. In this manner I would also like to mention the speaker's way of presentation. Sadek Drobi had a very intense speaking performance with lots of crazy and funny gesturing - and this fits brilliant to the speaker's fun in talking about the "Play experience". Well done Sadek!

So what's new in Play 2.0 Web Framework? A big thing is the native support for Java and Scala language simultaneously and the fact that Play 2.0 is part of the Typesafe stack. As the web applications out there evolve to a new era Play tries to fit the new requirements coming along with that. Over the years we have seen static HTML content with lots of dynamic extensions up to real time application components with Ajax, Long-polling, Web-Sockets and Live-Streams. Web applications nowadays need to handle huge amount of data in real time with different data stores. Play 2.0 Web Framework tries to handle these new challenges without loosing the Play experience.

What is the Play experience? A short demo showed the tremendous fast turnaround and the full stack capabilities when developing with Play. The Play command line tool gives you very easy access to operations like compile and run. Once a Play project runs in an embedded Web container the turnaround is very cool. You change something in your code e.g. in a controller, hit refresh in the browser and you are done. Much more effective is the error feedback within Play. Compile errors in your code get displayed in the browser immediately when you hit the refresh button. So you just have your code editor and the browser. No searching in the log for stack traces anymore. The cool stuff is that this also works with Java code in your Play project. Compile errors are displayed in the web browser after refresh. This also works with configuration files like routing configuration with Http method (GET, POST) and context path. A missing route in your Play configuration causes the very good readable Play error stack trace information in the browser. With Play this error feedback also works with less (CSS) style sheets. Love it!

So how to handle huge amount of data in new era web applications? You are limited in memory, threads and disk on the server. Http gives a good approach when sending huge data in chunks. But web frameworks on the server just read all data into the memory. Why not use InputStreams? The problem with InputStreams is that the read method blocks as soon as we have received a chunk - and it will block until the input data is complete. Play tries to solve this issue with reactive programming using inversion of control, but not loosing the control. Enumerators provide some amount of data in chunks. Iteratees receive data chunks incrementally. The control of data input is switched to enumerator component but the iteratee can always stop the processing when having received the data of interest. So the iteratee is able to filter the input and quit the data processing when done.

Besides that Play 2.0 integrates with client side technologies like CoffeeScript, Backbone.js, Dart, less (CSS), jQuery and much more. In addition to that the clean architecture of Play 2.0 has some good side effects. Type safety everywhere for solid application development, awesome performance boost (40.000 request per second on local laptop tests), easier integration with existing projects and minimal bootstrap.

I really liked this talk and I want to give it a try on Play 2.0 Web Framework in future! Besides that I need to get known to Scala, soon!


# "NoSQL for Java developers" by Chris Richardson (Alvin)

Chris Richardson from VMWare was giving a talk on NoSQL. He is working on Cloud Foundry and wrote the book "POJO in Action".

Relational databases are good and solid, but there are some challenges like

* Complex object graphs
* Semi structuren data schema
* Changes
* Scaling

How to overcome this issues? One way is to spend huge money buying hardware or have many many developers and administrators. Then, is NoSQL the solution? NoSQL has its on drawbacks and plus, so according to RIchardson the future is the polyglot persistence, i.e you have a mix of persistence with RDBMS, Caches, noSQL, Graph store etc.

So there are three major NoSQL databases:

* **Redis** (Advanced key-value store): very fast, transaction, master slave replication, scoring system
* **Cassandra** (Column oriented database/Extensible row store): very limited transaction, column family and super column family. Cassandra is interesting for Big Data applications
* **MongoDB** (document based): JSON based, provides a query language, tunable for write, scalable clustering support. MongoDB is going to be interesting for high volume writes, complex data or semi structured data.

There is a good amount of Dao support from Spring for NoSQL but the real issue is how the datamodel should look like for a NoSQL database?  For key/value system like redis and cassandra,  the best option is serialized data and the MongoDB already have a serialized form so that is straight forward there.

But how can i query the data against any thing other than the key. This is the real challenge for this, you have to de-normalize the data your self and store it in an index table. Richardson shows it how will work but it is a fair amount of work.

So the conclusion is: Be careful when you select your persistence, decouple your DAO layer so that you can easily switch to other backend. Think seriously about the polyglot persistence model.

# "What is Kotlin ?" by Andrey Breslav (Roland)

Kotlin is a statically typed, JVM based, general purpose language developed by Jetbrains. They wanted a modern expressive language for dealing with their own codebase (>50 k classes), but none existing language was a good fit.

Design goals:

* Full Java interoperatility
* Compiles fast
* More concise than Java
* Prevents more errors than Java

Tooling (compile, IDEA plugin, Eclipse plugin) will be open sourced and a first preview will be available soon.
Some of the major features are:

* Properties instead of fields
* First class functions
* Pattern matching
* Operator overloading
* Traits (code in interfaces)
* Extension functions (something like prototypes)
* Smart casts after type checks
* Inline functions
* Reified generics
* First class delegates

An example of Kotlin looks like:

    namespace hello

    fun main(args : Array<String>)  {
        var names = StringBuilder()

        for (i in args.indices) {
            names += args[i]
            if (i + 1 < args.size)
               names += ", "
        }

        println("Hello, $names!")
    }

    fun println(message : String) {
        System.out?.println(message)
    }

    fun StringBuilder.plusAssign(s : String) {
        this.append(s)
    }

So, except for having the type declaration on the right side it looks very familar to Java.
Most of the features were presented via examples and many questions were answered on the way. Inlining code is very cool. Kotlin seems to mixin ingredients from everywhere.

The real good thing about it that it will have tool support from the very beginning. That's much different to the other newcomers (Scala, Fantom, Groovy,...), so it is special and worth a look as soon as there is something to try out. The IDEA plugin was demonstrated, too. Quite neat and I can't wait to try it out. There were no date announced, though.

# "JAX-RS 2.0 RESTful Java on Steroids" by Marek Potociar (Christoph)

In his talk Marek Potociar sums up the new features in JAX-RS 2.0. Most of the new features are community driven and I will try to introduce them to you in this post.

New JAX-RS 2.0 features:

* Client API
* Filteres and handlers
* Validation
* Asynchronous processing
* Hypermedia
* Server-side content negotiation

I will not cover all of them in detail here as the talk was quite fast and content was huge. Probably this is also because it was the last talk of the day and my writing speed was not sufficient enough. So let us go into some details.

* *Client API* With JAX-RS 2.0 we are able to send REST Http client requests with a fine JAX-RS API and I think this is really great new feature. There is no handling of the Http request itself. Everything is done via a Java method DSL. With a simple call of 4-5 methods you are able to build a Http REST request with GET, POST, PUT and so on. You can also prepare several requests, collect them and invoke them later in a batch.
* *Filters & Handlers* RequestFilter and ResponseFilter implementations come with a FilterContext being able to get the request and response objects. Each filter can proceed or break the filter chain. ReadFromHandler and WriteToHandler come with a context on the actual input stream. As an example handlers can provide a zipped representation of a resource (e.g. GZipHandler).
* *Validation* The well known BeanValidation API is reused in JAX-RS 2.0. So you can use @NotNull, @Email, @Constraint annotations on path parameters for instance.
* *Asynchronous Processing* On server-side you simply inject a ExecutionContext and add the @Suspend annotation to your controller method. Inside the method you delegate the long-running operation to a separate thread. After the work is done the thread calls context.resume() and the asynchronous operation is completed. On client-side JAX-RS is able to invoke an InvocationCallback asynchronously for you. So you are able to receive a callback when the asynchronous operation is complete.
* *Hypermedia* Only transitional links are supported with Link and LinkBuilder implementations. You can build links from a resource method and use links in ResponseBuilder API.

This completes the feature list on JAX-RS 2.0 and I have to say that the client side API feels quite good to me. This completes JAX-RS to a full stack API on RESTful Java.

# "Phone Gap" by Brian Leroux (Torsten)

This was the third talk I attended today and it was my first "client side" talk at devoxx this year.

I've already heard some things about phone gap and roughly knew what it is about. I think it is quite an interesting approach for writing native mobile apps, especially for companies which have to provide those apps for not only one mobile platform. Besides that I was curious to see Brian Leroux live.

Unfortunately he was throwing his fully packed slides faster on the wall than I could even read them. So my blog post will not go into very much detail - I simply couldn't write fast enough.

Anyway.

Brian started with a short (and fast) overview of the history of PhoneGap. It has been started in 2008 as a "hack" which allowed to create native mobile apps as webapps. To be honest I didn't really get what the "hack" actually is.In 2009 some apps which have been created using PhoneGap have been refused by Apple to be included to the app store which raised a lot of public attention for PhoneGap. In the end the issue with apple has been resolved and today some hundreds of PhoneGap apps are available in the app store.  In 2010 IBM offered five full time developers to contribute to phone gap and a year later in 2011 Adobe aquired the company behind PhoneGap -Nitobi - and open sourced the product under the Apache, MIT and BSD licence. PhoneGap is free software now. Today RIM, IBM, Microsoft and others are actively supporting the PhoneGap development.

The philosophy behind PhoneGap is that "simple is better" and that the web is a first class application plattform. With PhoneGap you can basically create installable WebApps using Html, CSS and JavaScript. It provides device APIs for things like sensors, data, outputs - any native API is permitted. To actually build Apps the use of any Framework such as jQuery Mobile, Sencha Touch or JQTouch is possible. And according to Brian PhoneGap is just "a fancy web browser" in the end.

PhoneGap apps can be build using the cloud based "PhoneGap Build" service which creates the application for different plattforms. This avoids the developer from installing a dev environment for each target plattform. Currently it takes about two minutes to build your app using PhoneGap Build and according to Brian this shoul be reduced to 30 seconds in the near future. Brian also used a quite funny description of XCode. He said "XCode is worse than eclipse and looks like itunes".

He then gave some advice on topics such as testing, splitting up apps in multiple apps if the feature set gets to large. using json instead of xml, and so on...

And that was basically Brians talk.

I found to things quite astonishing: The first is Brians advice NOT to use a framework such as Sencha or jQuery in the first place and the second is that one should start building a MOBILE WEB APP and see PhoneGap as an enhancement technique.

I forgott to mention that NONE of his demos actually worked. Brians comments: "this piece of shit cable ... fuck!" and "super annoying". Anyway the photo sharing app demo can be found here: [https://gist.github.com/1219277](https://gist.github.com/1219277)

To sum it up, PhoneGap is very interesting, especially because everyone can write native apps using known technologies such as Html, CSS and JavaScript. The talk was quite good and entertaining but a little bit too fast or too packed if you want to. I will definetely have a closer look at PhoneGap.

# "Bleeding Edge HTML5" by Paul Kinlan (Roland)

Wow, the room for this talk was really overflowing. And it was really worth since Paul did a real cool presentation with demos of all those *bleeding* features coming down on us. But maybe it should have been called "Bleeding Edge Chrome Features" because that was what he showed and for me it is by no means clear, how the specification process will pick this up (or how the specification process works at all).

HTML-5 will probably come with a bunch of new tags:

* `<details>` klickable to open for more information
* `<output>` allows for easy update of output when input elements change
* `<mark>` semantically highlight texts
* Speech input by adding an attribute `x-webkit-speech` to an input
  element

Smarter Web applications are around the corner. Preprendering and page visibility API are optimization for the Web overall Web experience.
There will be events `online` and `offline` for detecting the online status.

Then to Web intents. They work like this:

* A service registers its intention to handle an action for the user.
* App requests to start an action
* User selects which service to use

It's much like Android intents but for the web.

Multimedia like camera and microphone access support is going to be available pretty soon. The fullscreen support allows to make any HTML element fill the full screen. WebRTC is a plugin-free high quality real-time voice/video communication in the browser (webrtc.org).
Web Audio API is for low latency audio playback which connects an input source to an output source.

The talks was a very interesting roundtrip through a multitude of forthcoming Chrome features, although there were some problems with the demos. Tipp: [chromestatus.com](http://chromestatus.com) contains the latest implementation status of HTML 5 features.

# "The File System API in JDK 7" by Alan Bateman (Christian)

After a long day I visited this not-too-challenging lesson about the new Filesystem API in Java 7. After a short introduction into the limits of the old java.io-API Alan Bateman listed the new java.nio.file-types with many, many samples. Since you can get everything also in an [online tutorial](http://download.oracle.com/javase/tutorial/essential/io/fileio.html), I will just give a few sourcecode-examples for a quick glance at the features. Just imagine, how you still code the same functionality with JDK6 ;-):

## Files

* provides static methods for file-operations
* now always throws IOException (and subclasses), but **no more checked exceptions**!

```java
byte[] bytes = Files.readAllBytes(path);
List<String> lines = Files.readAllLines(path, UTF_8);
BufferedReader reader = Files.newBufferedReader(path, UTF_8);
BufferedWriter writer = Files.newBufferedWriter(path, UTF_8);
InputStream in = Files.newInputStream(path);
OutputStream out = Files.newOutputStream(path, CREATE, APPEND); // optional standard open options (import java.nio.file.StandardOpenOption.*)
Files.copy(source, target, REPLACE_EXISTING, COPY_ATTRIBUTES); // optional copy options (import java.nio.file.StandardCopyOption.*)
```

## Symbolic links

```java
Files.isSymbolicLink(path);
Files.createSymboicLink(linkPath, path);
Files.isSameFile(path1, path2);
Files.readAttributes(path, BasicFileAttributes.class, NOFOLLOW_LINKS); // optional link option: really get the attributes of the link
```

## File Attributes

```java
PosixFileAttributes attrs = Files.readAttributes(path, PosixFileAttributes.class);
attrs.owner();
attrs.group();
attrs.permissions();
Set<PosixFilePermission> perms = PosixFilePermissions.fromString("rw-r-----");
```

## DirectoryStream

This is useful for performant access to large directories (implements Iterable), e.g. get all .java-files:

    DirectoryStream<Path> stream = Files.newDirectoryStream(dir, "*.java");

## File changing notification

The good thing is, that ther is **no more polling!!!** anymore. This can be done via the
`WatchService` (with multi-threading support):

```java
WatchService watcher = FileSystems.getDefault().newWatchService();
WatchKey key = path.register(watcher, ENTRY_CREATE, ENTRY_DELETE);

while (true) {
   WatchKey key = watcher.take();
   for (WatchEvent<?> : key.pollEvents()) {
      if (event.kind() == ENTRY_CREATE) {
         Path name = (Path) event.context();
         System.out.format("%s created. Happy Devoxx!!\n", name);
      }
   }
   key.reset();
}
```

# "Working off the grid - HTML5 offline" by Sam Dutton (Jan)

Sam Dutton from Google introduced offline storage capabilities coming up with HTML5 in this talk. The actual demand for offline capabilities arises from

* Connectivity issues (no/low/unreliable)
* Performance and resource (think of mobile battery!) consumption
* Reliability and security (send less sensitive information over wires)
* User experience

Several kinds of local storage capabilities in HTML5 were introduced and demonstrated:

## Web Storage (aka localStorage/sessionStorage) for unstructured data

Local storage is a very simple key/value store like persistence concept - basically it stores strings.

Usage is quite easy:

```java
if (!localStorage.getItem("checkins")) {
   localStorage.saveItem("checkins", myDataAsJsonForExample))
}
```

Session storage works similar as local storage, but the persistence lasts only as long as the browser is opened. The same origin policy kicks in as well for local storage, so that data can only be accessed from the same domain as it was stored from. Chrome dev tools can be used to inspect the current data in local/session storage (not yet supported for IndexedDB, but soon to come)

## IndexedDB/WebSQL

IndexedDB and WebSQL are more advanced concepts, providing storage capabilities for structured data and transaction support.

* *IndexedDB* This works similar to NoSQL document databases like MongoDB, there is no scheme, no SQL, it stores JavaScript objects. Search is done via index.
Currently only Chrome and Firefox have implemented it.
* *WebSQL* WebSQL is a relational database supporting SQL, and is quite well and broadly supported on mobile browsers already.
Lawnchair is a Javascript abstraction layer to provide a better ease of use

## App Cache

App cache is a local cache for static resources which can be activated by a special cache configuration, called app cache manifest. It can store and cache an entire web app locally - make sure to serve your appcache manifest with the specified mime-type text/cache-manifest to avoid that it.

## File system API

HTML5 provides a file system storage, using the filesystem:-URL prefix. The data is stored in some kind of virtual filesystem, so you will not find it browsing your OS-directories of course. The same origin policy is applied here as well.

Some more interesting observations from this talk:

* In HTML5, you can check whether your system has in internet connection by calling navigator.isOnline() in JS
* IE has only implemented local storage so far. Does Microsoft WANT to be kicked off the browser market? What's wrong here?
* Different browsers can not reuse the same filesystem storage - this is a really bad thing IMO and needs to be resolved.

A really interesting talk, the hour was fully packed with stuff and the speaker was very fast - hard job to listen and blog in parallel. Can be recommended to everyone interested in the current status of HTML5 offline capabilities.